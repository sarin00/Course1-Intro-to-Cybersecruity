## 1. Diffie-Hellman, створення спільного ключа по незахищеному каналу
Коли ми передаємо дані через інтернет, ми хочемо їх зашифрувати, щоб ніхто посторонній не зміг прочитати вміст наших даних. Уявімо собі що ви хочете віправляти зашифровані дані своєму другу, відповідно він має їх розшифровувати. Для цього нам потрібен ключ який знатимете і ви, і ваш друг. Ви хочете передати ключ другу, але якщо зловмисник побачить цей ключ в процесі передачі то зможе читати подальші повідемлення. Ви не можете зашифрувати свій ключ бо саме цей ключ і потрібен вашему другу для розшифровування даних. Невже нам потрібно фізично зустрітись і поділитись ключем з другом щоб передавати зашифровані дані через інтернет?  
Рішення є - алгоритм обміну ключем `Diffie-Hellman (DH)`, або Diffie-Hellman key exchange.  
`DH - це криптографічний алгоритм, який дозволяє сторонам узгодити спільний секрет через незахищений канал спілкування без безпосередньої передачі цього секрету. `  
Дуже важливо розуміти, що секрет який створиться в результаті роботи DH не має використовуватись безпосередньо як ключ шифрування, а як основа для створення подальших ключів шифрування. Це пов'язано з кількома речами, в тому числі з тим що ключі для симетричного шифрування треба міняти раз на деяку кількість зашифрованих даних.  
Цей алгоритм поясниться тут абстрактно з використанням кольорів (для тих кому не цікава математика), та математично з дуже маленькими числами.  

## 1.1 Абстрактне пояснення роботи DH
Для простоти абстрактного пояснення будуть використані кольори. Майте на увазі, що схема дуже спрощена і не вдається в деталі роботи алгоритму (це робиться в секції з математичним поясненням).  
В нашій схемі будуть використані наступні значення:  
Аліса та Боб - дві сторони які хочуть узгодити спільний секрет через Інтернет для подальшого шифрування своїх повідомлень.  
`g` - число "генератор". Це число має бути відомим обом сторонам і може передаватись через інтернет. Зловмисник може його бачити, в цьому нема нічого страшного.  
`a` - секретне число яке генерує Аліса і нікому ніколи його не повідомляє.  
`b` - секретне число яке генерує Боб і нікому ніколи його не повідомляє.  

Хід дій:  
1. Аліса та Боб генерують свої секретні числа `a (червоне)` та `b (синє)` відповідно. Ці числа беруть участь в математичних операціях, але ніколи нікому не передаються.
2. Аліса розраховує "публічне" число `ag (помаранчеве)` шляхом змішання публічного генератора `g (жовте)` та особистого секретного `a`. Боб робить те саме, тільки зі своїм особистим секретним `b` та публічним `g` та розраховує `bg (зелене)`.
3. Аліса передає публічне `ag` Бобу, а Боб передає публічне `bg` Алісі. Хоча зловмисник і знає на цей час значення `g`, `ag`, та `bg`, математично розрахувати секретні `a` чи `b` дуже важко. Ця проблема розрахування називається проблемою дискретного логарифму.
4. Аліса розраховує остаточний спільний секрет змішуючи публічне число від Боба `bg` зі своїм особистим секретом `a` та отримує `abg (коричневе)` в результаті. Боб розраховує остаточний спілький секрет змішуючи публічне число від Аліси `ag` зі своїм особистим секретом `b`, і теж отримує `abg (коричневе)`. Таким чином, обидві сторони мають спільне `abg`, яке ніколи безпосередньо не передавалось між Алісою та Бобом. При цьому, зловмисник знає тільки `g`, `ag`, `bg`, чого недостатньо щоб розрахувати кінцевий секрет.  
![DH abstract](https://github.com/sarin00/Course1-Intro-to-Cybersecruity/blob/main/%D1%8F%D0%94%D0%BE%D0%B4%D0%B0%D1%82%D0%BA%D0%BE%D0%B2%D1%96%20%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D1%96%D0%B0%D0%BB%D0%B8/DH_abstract.png)

## 1.2 Математичне пояснення роботи алгоритму DH на маленьких числах
Математика цього алгоритму базується на модульній арифметиці і простому математичному правилу що вивчається у школі:  
$(g^a)^b = (g^b)^a$  
Значення які ми використовуватимемо в розрахунках (всі числа цілі, назви змінних такі самі як і в абстрактному поясненні):  
`g` - це число-генератор. Це маленьке просте число яке відемо всім, в тому числі і зловмиснику.  
`n` - це модуль за яким будуть проходити всі математичні розрахунки. Це дуже велике просте число довжиною у 4000 бітів. `n` теж відомо всім учасникам заздалегідь, в тому числі і зловмиснику.  
`a` - це секретне число яке обирає користувач Аліса. `a` має бути між 1 та n, $1 < a < n$.  
`b` - це секретне число яке обирає користувач Боб. `b` має бути між 1 та n, $1 < b < n$.  
`ag` - це число яке Аліса передає Бобу. Воно розраховується як $g^a mod n$. Це число відомо зловмиснику.   
`bg` - це число яке Боб передає Алісі. Воно розраховується як $g^b mod n$. Це число відомо зловмиснику.  
`abg` - це фінальний спільний секрет, який Боб та Аліса самостійно розраховують, використовуючи математичну властивість $(g^a)^b = (g^b)^a$. Боб бере `ag` Аліси, і зводить його у степінь свого секретного `b` ось так: `abg = ag^b`. В реальності це виглядає як $abg = (g^a)^b$. В цей час Аліса бере `bg` Боба, взводить його у свою секретну степінь `a` та рохраховує його як $abg = (g^b)^a$.  

Математичне обчислення:  
1. Для прикладу $g = 53; n = 997$
2. Аліса обирає своє секретне число, $a = 100$
3. Боб обирає своє секретне число, $b = 300$
4. Аліса розраховує `ag` і передати його Бобу. $ag = g^a mod (n)$;  $ag = 53^100 mod 997 = 390$
5. Боб розраховує `bg` і передає його Алісі. $bg = g^b mod (n)$;  $bg = 53^300 mod 997 = 491$
6. Аліса отримала `bg = 491` від Боба і розраховує спільний секрет `abg`. $abg = bg^a mod (n)$  $abg = 491^100 mod (997) = 247$
7. Боб отримав `ag = 390` від Аліси і розраховує спільний секерт `abg`. $abg = ag^b mod (n)$  $abg = 390^300 mod (997) = 247$
8. Причина чому це спрацювало в тому, що $(53^100)^300 mod (n) = (53^300)^100 mod (n)$, тобто $(g^a)^b = (g^b)^a$.  
