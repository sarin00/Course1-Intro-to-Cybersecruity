## 1. Вступ
Криптографічні системи - це не тільки про шифрування даних. Різні системи та алгоритми виконують багато критичних задач, без яких Інтернет виглядав би зовсім інакше. Декілька систем часто використовуються в комбінації одна з одною для досягненя тих чи інших цілей.
Наша задача познайомитись з цими системами, з конкретними алгоритмами, з ситуаціями в яких їх треба використовувати, і з best-practices з їх використання, без того щоб вдаватись в математику (ну хіба що трішки).  

Ми вивчимо системи які виконують наступні функції:  
1. Хешування
2. Шифрування (Симетричне та Асиметричне)
3. Обмін секретом через незахищений канал (Інтернет)
4. Цифровий підпис

## 2. Хешування
`Хешування` - це функція, яка приймає на вхід дані довільної довжини, виконує операції над даними щоб їх трансформувати, і видає результат фіксованої довжини.  

Ми можемо порахувати хеш для одного слова, а можемо порахувати хеш від картинки чи багатогігабайтного файлу - результат зажди буде однакової, обмеженої довжини. Не плутати хешування з шифруванням, це дуже різні функції з різними принципами і цілями роботи.  

Задачу хешування можна порівняти з відбитком пальців, або fingerprint. Хеш від якихось даних - це наче умовно унікальний відбиток цих даних. Для одних і тих самих вхідних даних хеш завжди буде однаковим. Зміни дані хоч трішечки - і хеш від них кардинально зміниться. Ця властивість використовується в багатьох різних ситуаціях та протоколах (автентифікація, шифрування, цифрові підписи, тощо, в комбінації з іншими криптографічними системами).

### Виконайте завдання:
1. Зайдіть на сайт з [онлайн калькулятором хешів](https://www.pelock.com/products/hash-calculator) і порахуйте хеш для будь-якого слова  
2. Змініть одну букву в своєму слові, і порахуйте новий хеш для цього слова  
3. Зверніть увагу наскільки сильно через одну букву результат хешу змінюється  

`Властивості функцій хешування:`  
1. Однаковий input завжди видає однаковий output  
2. Незворотність. Маючи хеш від якихось даних, неможливо математично порахувати якими були ці дані на вході. (Не плутати з rainbow table атакою, це не зворотнє розрахування)
3. Колізії. Коли на вхід можна надавати "безкінечно" довгі дані, а на виході довжина хешу обмежується, то потенційних комбінацій вхідних даних більше, ніж всіх потенційних результатів хешу. Через це іноді різні дані на вході можуть мати однакові хеші на виході (це і є Колізія).

## 3. Алгоритми хешування
1. `MD5` Застарілий алгоритм, хеш 128 біт в довжину, занадто слабкий для сучасних систем і не рекомендується до використання  
2. `SHA-1` Застарілий алгоритм, хеш 160 біт в довжину, занадто слабкий для сучасних систем і не рекомендується до використання  
3. `SHA-256` Хеш 256 бітів в довжину. Ця функція хешування є стандартом для більшості систем, маючи достатній рівень стійкості та відносно прийнятну швидкість. Якщо не знаєте який алгоритм хешування використати - використайте цей.  
4. `SHA-384` Достатньо безкорисна функція, була розроблена через те що державні агенції США вимагають security level в 384 "bits of security" для обробки секретної (Top Secret) інформації. Для обрахування SHA-384 потрібно зробити стільки ж операцій як і для SHA-512, при цьому security level в SHA-512 вищий. Якщо маєте справу ну з дуже секретними даними - краще використати SHA-512. 
5. `SHA-512` Цей алгоритм хешування потрібен для дуже чутливих систем що обробляють секретні дані. У звичайних системах в SHA-512 нема необхідності, він тільки займатиме більше часу для обрахування в порівнянні з SHA-256.

## 4. Використання хешування для збереження паролів користувачів
Уявімо собі що в нас є веб застосунок в якому ми дозволяємо користувачам створювати облікові записи. Для того щоб автентифіковувати користувачів (підтверджувати що вони і справді є власниками цих облікових записів) ми просимо користувачів створити username та пароль. Тільки вони мають знати свій пароль, відповідно якщо вони нам його нададуть разом з username то наше підтвердження особистості можна вважати успішним.  
Питання в тому як зберігати паролі користувачів. Є тільки одна правильна відповідь - ЗАМІСТЬ ЗБЕРЕЖЕННЯ ПАРОЛІВ ТРЕБА ЗБЕРІГАТИ ХЕШІ ЦИХ ПАРОЛІВ. Коли ми говоримо про базу даних користувачів, то різні люди, системи, сервіси мають доступ до цієї бази. Якщо ми зберігатимемо паролі у відкритому вигляді, якийсь розробник може просто прочитати паролі користувачів з цієї бази, потім залогінитись в наш сервіс від імені цих користувачів, і робити шкоду. Також, якщо наша база даних буде вкрадена, зловмисники отримають до неї несанкціонований доступ - ми стикаємось з тією самою проблемою. Нам потрібно мати можливість перевірити пароль користувача при цьому не зберігаючи цей пароль. Навіть якщо ми зашифруємо базу з паролями, то пароль шифрування буде зберігатись десь в системі і теж може бути вкраденим, не кажучи вже про складність ротації цього паролю та обмеження доступу до нього.  
З властивостей функцій хешування ми памʼятаємо, що однаковий input завжди дає однаковий output. Тобто, якщо мій пароль буде `password123`, то SHA-256 хеш для цього паролю завжди буде `EF92B778BAFE771E89245B89ECBC08A44A4E166C06659911881F383D4473E94F`. Неважливо коли, хто, яка система буде розраховувати цей хеш, він завжди буде однаковим для слова password123.  

Як це виглядатиме:  
1. Користувач реєструється у нашому застосунку і створює пароль `password123`
2. Наш веб застосунок отримує дані від користувача, розраховує хеш для password123 (використовуючи функцію типу PBKDF2, додаючи сіль, про це пізніше) і зберігає хеш, наприклад `F3AB6D7F779DDC29DA66448FF3711AF1DF1289C9DE16F5D76C918D9F3EF63B2E`, в базі разом з іншими даними користувача. При цьому пароль наш застосунок повністю забуває.  
3. Наступного дня користувач хоче залогінитись у свій аккаунт. Він надсилає нам свій username та пароль password123.  
4. Наш застосунок знаходить обліковий запис користувача у базі, зчитує яка сіль була використана для хешування паролю цього користувача, розраховує хеш функцією PBKDF2 для password123 з сіллю (результатом розраховування виявляється `F3AB6D7F779DDC29DA66448FF3711AF1DF1289C9DE16F5D76C918D9F3EF63B2E`), і перевіряє чи хеш у базі співпадає з хешем який тільки що порахувався. Якщо співпадає, значить користувач надав правильний пароль, якщо не співпадає - значить пароль було введено невірно.
Таким чином в нас є можливість верифікувати пароль користувача без зберігання самого паролю.

### Сіль в хешуванні
Що станеться якщо база даних з хешами паролів все ж таки буде викрадена? Пан чи пропав залежить від того, чи використовували ми сіль при хешуванню паролів. Хоча математично не можна порахувати з хешу яким заме був пароль, можна натомість викорисатати rainbow table attack.  
Оскільки хеші розраховуються завжди однаково, і алгоритм хешування доступний всім, то зловмисники заздалегідь розраховують мільйони хешів для мільйонів популярних паролів. Така таблиця з заздалегідь розразованими паролями може виглядати так:  
```
SHA-256
password123 EF92B778BAFE771E89245B89ECBC08A44A4E166C06659911881F383D4473E94F
Pa$$word 3C1A9273CC94381AD848FDD8991531A28B17B34ABAF5AB5131A9A7348D5840E2
qwerty123 D70E25E734DEDBD1CA52FE81459B23AF88F82819D06A823E07A79A86955E8AC8
і так далі для мільйонів паролів і різних алгоритмів хешування
```
Після того як зловмисники викрадають нашу базу з хешами, вони вираховують який алгоритм хешування ми використовували та почнуть шукати у цих заздалегідь прорахованих базах який саме пароль матиме відповідний хеш. Уявімо собі що ми зловмисники і вкрали базу з SHA-256 хешами паролів. Використовуючи список вище та [онлайн базу з хешами та паролями](https://crackstation.net/), дізнайтесь які паролі призводять до цих SHA-256 хешів:  
1. 3C1A9273CC94381AD848FDD8991531A28B17B34ABAF5AB5131A9A7348D5840E2
2. ef797c8118f02dfb649607dd5d3f8c7623048c9c063d532cc95c5ed7a898a64f
3. 5a012756f3fe06210fe8f3afca3176541d8ad232e9d34aa5aedf7c19715ad4b9
4. b6460e904031d3ebc1b7eeadd23a9704b29ceccb0b8bb7eb0a2eba620ceaf755
5. 282C9E0083B9CB84FAADC68AEE38B5AE1DC069995AB52774874B9D368E465907

Для того щоб вирішити цю проблему потрібно забрати у зловмисників можливість використовувати заздалегідь прораховані хеші. Для цього, замість розраховування хешу від паролю користувача ми додаватимемо сіль (якісь випадкові біти) до паролю цього користувача. Наприклад, наш користувач обрав `password123` як свій пароль, ми згенерували випадкову строку `QxuNL_W!eo` як сіль і порахуємо хеш для `password123QxuNL_W!eo` алгоритмом SHA-256 та отримаємо `bad574edbef29c45b89bad33ae4ea1d51d598a5ca1255c05ce6a6c585883ee27` як результат. Для простоти прикладу ми використали маленьку сіль, але в реальності вона має бути сильно більшою. Ось які дані ми б зберегли у базі даних про цього користувача: 
```
Username    Salt_value  Password_hash
john.smith  QxuNL_W!eo  bad574edbef29c45b89bad33ae4ea1d51d598a5ca1255c05ce6a6c585883ee27
```
Якщо наша база буде вкрадена, зловмисник побачить значення солі, але тепер щоб вгадати один пароль для одного john.smith йому потрібно буде самостійно розраховувати нову rainbow table з мільйонами потенційних паролів з нашою сіллю і їх хешів. Таку ж таблицю з новими мільйонами хешів йому доведеться розраховувати для кожного користувача, бо солі в користувачів різні. Один пароль того не вартий. Нам не страшно втратити сіль та хеш паролю, бо зусилля для розрахунку такого паролю будуть величезними для хакера. Якщо ми використовуватимемо однакову сіль для всіх користувачів, то зловмиснику доведеться розраховувати тільки одну таблицю rainbow table з мільйонами записів, що може бути того варто. СІЛЬ МАЄ БУТИ УНІКАЛЬНОЮ ДЛЯ КОЖНОГО КОРИСТУВАЧА!

### Висновки по Хешуванню
1. Для будь-якої незрозумілої ситуації використовуйте SHA-256, а для секретної інформації - SHA-512.
2. НІКОЛИ не зберігайте паролі користувачів у відкритому чи зашифрованому вигляді. Паролі треба зберігати тільки у виглядів ХЕШІВ від паролів.
3. ЗАВЖДИ додавайте сіль до паролю для кожного користувача.
4. Сіль має бути випадковою для кожного користувача.
5. Хеш від паролю має розраховуватись на бекенді, клієнт (браузер, мобільна апка, тощо) ніколи не має знати про свій хеш, свою сіль, і т.д.
6. Для правильного створення хешів для паролів треба використовувати функції що виконують багато раундів хешування паролю, використовують сіль, наприклад PBKDF2.

## 5. Додаткові матеріали
1. [Як працює хешування](https://www.practicalnetworking.net/series/cryptography/hashing-algorithm/)  
